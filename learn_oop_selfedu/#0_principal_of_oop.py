
"""
Концепция ООП простыми словами
https://proproprogs.ru/python_oop/koncepciya-oop-prostymi-slovami
"""

# Класс / Шаблон
# Объект / Экземпляр
# Атрибут / Свойство / Данные
# Метод

# Инкапсуляция
"""Чтобы пользователь класса не мог случайно или намеренно вмешаться в его внутреннюю работу, данные и методы можно 
скрывать. То есть, к скрытым данным и методам нельзя напрямую обращаться извне, только внутри класса. Такой механизм 
в ООП называется инкапсуляцией. Благодаря инкапсуляции класс становится единым целым, а работа с ним возможна только 
через разрешенные (публичные) свойства и методы."""

# Наследование
"""Наследование позволяет как бы вынести «за скобки» общее для разных классов. """

# class Line:
#     coords = ''
#     width = ''
#     color = ''
#
#     def draw(self):
#         pass
#
#
# class Rect:
#     coords = ''
#     width = ''
#     color = ''
#
#     def draw(self):
#         pass
#
#
# class Ellipse:
#     coords = ''
#     width = ''
#     color = ''
#
#     def draw(self):
#         pass


"""Очевидно, в этих классах будут общие свойства: coords, width и color. Получаем дублирование кода, то есть, нарушение 
принципа DRY – не повторяйся. Именно эти общие свойства целесообразно вынести в общий для всех них базовый класс 
Figure"""


class Figure:
    coords = ''
    width = ''
    color = ''

    def draw(self):
        pass


class Line(Figure):

    def draw(self):
        pass


class Rect(Figure):

    def draw(self):
        pass


class Ellipse(Figure):

    def draw(self):
        pass


# Полиморфизм
"""В программировании различают два вида полиморфизма. Это, так называемый, Ad hoc полиморфизм и параметрический 
полиморфизм. Первый, Ad hoc существовал еще до появления ООП и реализовывался через перегрузку функций и приведение 
различных типов данных."""
# double abs(double x) {
# return (x < 0) ? –x: x
# }
#
# int abs(int x) {
# return (x < 0) ? –x: x`
# }

"""Благодаря параметрическому полиморфизму, мы можем оперировать разными типами объектов через их единый базовый класс, 
в нашем случае Figure. Достаточно создать список, каждый элемент которого будет иметь тип Figure и через ссылку на 
базовый класс вызывать функцию draw(). Причем автоматически будет вызван метод draw() соответствующего дочернего 
класса. Так устроено наследование в ООП. В результате, мы имеем единый интерфейс – класс Figure для управления самыми 
разными типами графических примитивов. Причем, в будущем в программу можно добавлять новые графические классы, просто 
унаследовав их от Figure и они автоматически будут встраиваться в общую логику работы программы"""

