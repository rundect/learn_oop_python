
"""
Наследование в объектно-ориентированном программировании
https://proproprogs.ru/python_oop/python-nasledovanie-v-obektno-orientirovannom-programmirovanii

Такая конструкция, когда один класс определяется на основе другого, называется наследованием. Причем, класс Geom
называется родительским или базовым, а класс Line – подклассом родительского или дочерним классом.
"""


# class Geom:
#     name = 'Geom'
#
#
# # class Line:
# #     def draw(self):
# #         print("Рисование линии")
#
#
# class Line(Geom):
#     def draw(self):
#         print("Рисование линии")
#
#     def set_coords(self, x1, y1, x2, y2):
#         self.x1 = x1
#         self.y1 = y1
#         self.x2 = x2
#         self.y2 = y2
#
#
# class Rect(Geom):
#     def set_coords(self, x1, y1, x2, y2):
#         self.x1 = x1
#         self.y1 = y1
#         self.x2 = x2
#         self.y2 = y2
#
#     def draw(self):
#         print("Рисование прямоугольника")


"""
Как видите, у нас здесь налицо дублирование кода. И оно будет быстро нарастать с увеличением классов для 
различных геометрических фигур. Чтобы этого не было, мы можем общее для всех дочерних классов (от Geom) 
вынести в базовый и, в частности, записать в нем метод set_coords. В итоге получим, следующие определения классов: 
"""


class Geom:
    name = 'Geom'

    def set_coords(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        # self.draw()

    def draw(self):
        print("Рисование примитива")

    """
    То же самое происходит и при переопределении методов. Давайте добавим в класс Geom метод draw():
    и видим, что у этого метода в базовом классе нарисована стрелочка вниз, а в дочерних – стрелочка вверх. Это и 
    есть обозначения переопределения методов. 
    """


class Line(Geom):
    name = 'Line'
    """
    Кстати, когда мы определяем какой-либо существующий атрибут в дочернем классе – это называется 
    переопределением. То есть, мы переопределили атрибут name, который присутствует в базовом классе Geom 
    и интегрированная среда нам об этом сигнализирует стрелочкой вверх. 
    """

    def draw(self):
        print("Рисование линии")


class Rect(Geom):
    def draw(self):
        print("Рисование прямоугольника")


# g = Geom()
# print(g.name)
#
# l = Line()
# l.draw()
# print(l.name)

l = Line()
r = Rect()

l.set_coords(1, 1, 2, 2)
r.set_coords(1, 1, 2, 2)

"""
Как отрабатывает метод set_coords базового класса Geom? Во-первых, когда происходит его вызов, например, 
через объект класса Line, то метод с таким названием сначала ищется в классе Line и если не находится, то 
поиск продолжается в базовых классах. В данном случае – это класс Geom. В нем этот метод обнаруживается и 
запускается.
Во-вторых, при вызове метода set_coords() из базового класса его параметр self будет ссылаться на объект, 
через который этот метод был вызван. То есть, на объект класса Line. Вот это очень важный момент! Параметр 
self в базовых классах может ссылаться не только на объекты этого же класса, но и на объекты производных 
(дочерних) от него классов, как в нашем случае – на объект класса Line. Почему это важно? Смотрите, формально 
сейчас мы можем в методе set_coords() вызвать метод дочернего класса draw(): 
"""

g = Geom()
g.set_coords(0, 0, 0, 0)
"""
Параметр self метода set_coords() ссылается на объект базового класса Geom, а в нем метод draw отсутствует. 
Отсюда и получается такая ошибка. Поэтому, при реализации методов в классах следует придерживаться одного 
простого правила: внутри них обращаться только к разрешенным атрибутам либо внутри текущего класса, либо 
базовых классов. Но не дочерних. 
"""

print(l.name)
print(r.name)

l.draw()
r.draw()
g = Geom()
g.draw()
