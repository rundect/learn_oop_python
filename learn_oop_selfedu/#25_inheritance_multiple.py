
"""
Множественное наследование
https://proproprogs.ru/python_oop/python-mnozhestvennoe-nasledovanie

-0-
В языке Python допускается множественное наследование, когда один дочерний класс образуется сразу от нескольких
базовых, согласно синтаксису:
class A(base1, base2, …, baseN):
    pass
"""


class Goods:
    def __init__(self, name, weight, price):
        """
        -1-
        При создании объектов инициализатор ищется сначала в дочернем классе, но так как его там нет, то в первом
        базовом Goods. Он там есть, выполняется и на этом инициализация нашего объекта NoteBook завершается. Однако,
        нам нужно также взывать инициализатор и второго базового класса MixinLog. В данном случае, сделать это можно
        с помощью объекта-посредника super(), которая и делегирует вызов метода __init__ класса MixinLog
        """
        super().__init__()
        print("init Goods")
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f"{self.name}, {self.weight}, {self.price}")


class MixinLog:
    ID = 0

    def __init__(self):
        print("init MixinLog")
        self.ID += 1
        self.id = self.ID

    def save_sell_log(self):
        print(f"{self.id}: товар продан в 00:00 часов")

    def print_info(self):
        print("print_info класса MixinLog")


class MixinLog2:
    def __init__(self):
        """
        -5-
        Чтобы в программах при множественном наследовании не возникало проблем с зависимостью последовательности
        наследования дополнительных базовых классов, их инициализаторы следует создавать с одним параметром self и
        в каждом из них прописывать делегированный вызов инициализатора следующего класса командой:
        super().__init__()
        """
        super().__init__()
        print("init MixinLog 2")


"""
-4-
Поменяем местами базовые классы и мы сразу получаем ошибку, что в метод __init__ передаются четыре 
аргумента, а он принимает только один, так как здесь отрабатывает инициализатор уже класса MixinLog. 
Так что порядок следования базовых классов при множественном наследовании имеет важное значение. 
Первым должен идти «основной» класс и у него, как правило, инициализатор имеет несколько параметров. 
А далее, записываются классы, у которых, опять же, как правило, инициализаторы имеют только параметр 
self. Это второй важный момент. Когда мы собираемся использовать множественное наследование, то 
структуру классов следует продумывать так, чтобы инициализаторы вспомогательных классов имели только 
один параметр self, иначе будут сложности их использования
"""


class NoteBook(Goods, MixinLog, MixinLog2):
    def print_info(self):
        MixinLog.print_info(self)


n = NoteBook("Acer", 1.5, 30000)
n.print_info()
n.save_sell_log()

"""
-2-
откуда функция super() «знает», что нужно обратиться ко второму базовому классу MixinLog, а, скажем, не к 
базовому классу object, от которого неявно наследуются все классы верхнего уровня? В Python существует 
специальный алгоритм обхода базовых классов при множественном наследовании. Сокращенно, он называется 
MRO – Method Resolution Order 
Мы можем увидеть эту цепочку обхода базовых классов, если распечатать специальную коллекцию __mro__ любого класса
"""
print(NoteBook.__mro__)

"""
-3-
Методы сначала ищутся в самом классе NoteBook, затем, в классе Goods, далее идет класс MixinLog и от него уже 
идет к классу object. Это цепочка обхода для нашего конкретного примера. При другой иерархии наследования эта 
цепочка может быть другой, но одно всегда неизменно –первый базовый класс, указанный при наследовании, 
выбирается первым (после дочернего, разумеется). И это важный момент. Вы всегда можете быть уверены, что 
инициализатор первого базового класса сработает в первую очередь. Почему это важно? Смотрите, при создании 
объекта NoteBook мы передаем ему три аргумента. Эти три аргумента, затем, передаются в инициализатор. И 
так как первым будет вызван инициализатор класса Goods, то мы уверены, что эти аргументы будут переданы 
именно в него, а не в какой-то другой инициализатор других базовых классов. И какая бы цепочка наследования 
у нас ни была, все равно первым будет вызываться метод __init__ класса Goods, потому что он записан первым. 
Это гарантирует работоспособность нашей программы при разных иерархиях множественного наследования
"""

"""
-6-
Вызов методов с одинаковыми именами из базовых классов. Давайте предположим, что в классе MixinLog 
имеется метод print_info с тем же именем, что и в классе Goods:
    def print_info(self):
        print("print_info класса MixinLog")
Понятно, что если сейчас его вызвать через объект класса NoteBook:
n.print_info()
то мы обратимся к методу класса Goods, так как он записан первым в цепочке наследования и в соответствии с 
алгоритмом обхода MRO он будет найден первым. Но что если мы хотим вызвать этот метод из второго базового 
класса MixinLog? Как поступить? Сделать это можно двумя способами. Либо напрямую вызвать этот метод через 
класс MixinLog:
MixinLog.print_info(n)
Обратите внимание, что в этом случае нам обязательно нужно указать первым аргументом ссылку на объект класса 
NoteBook. Либо, определить какой-либо метод в классе NoteBook (пусть он называется также):
class NoteBook(Goods, MixinLog):
    def print_info(self):
        MixinLog.print_info(self)
И тогда будет вызываться метод именно второго базового класса MixinLog.
Обычно, если нужно делать такие подмены, то есть, из конкретного дочернего класса вызывать метод другого 
(не первого) базового класса, то создают метод в дочернем классе с тем же именем, а затем, явно указывают 
нужный базовый класс. 
"""
