"""
Как работает __slots__ с property и при наследовании
https://proproprogs.ru/python_oop/python-kak-rabotaet-slots-s-property-i-pri-nasledovanii
"""


class Point2D:
    __slots__ = ('x', 'y', '__length')

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.__length = (x * x + y * y) ** 0.5

    @property
    def length(self):
        return self.__length

    @length.setter
    def length(self, value):
        self.__length = value


pt = Point2D(1, 2)
print(pt.length)
"""
-0-
Обращаемся к свойству length, хотя в __slots__ нет такого разрешенного имени. И при этом нет никаких ошибок 
выполнения. В принципе, так и должно быть, потому что length – это не локальная переменная экземпляра класса, 
а атрибут класса Point2D. Коллекция __slots__ не накладывает ограничения на атрибуты класса, только на 
локальные атрибуты его экземпляров. Благодаря этому и появляется свойство length, которое работает как 
геттер и сеттер класса Point2D
"""
# print(pt.__dict__)  # AttributeError: 'Point2D' object has no attribute '__dict__'
print(pt.__slots__)


# ------------Поведение __slots__ при наследовании классов
class Point3D(Point2D):
    """
    -2-
    Если мы ее пропишем даже без указания каких-либо элементов: __slots__ = (), то ограничения вступят в свои
    права и она будет как бы унаследована от базового класса Point2D. То есть, в классе Point3D сейчас доступны
    только два локальных свойства x и y. Но нам нужно разрешить еще одно имя z. Для этого достаточно одно его
    и прописать в этой коллекции. Обратите внимание на висячую запятую. Она означает, что z – это элемент
    кортежа, а не просто строка. Предпочтительно записывать в таком виде. Хотя, и без запятой тоже все
    будет работать.
    """
    __slots__ = 'z',

    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z


pt3 = Point3D(10, 20, 30)
# pt3.z = 30
"""
-1-
Особенности работы коллекции __slots__ при наследовании классов. Создаем еще один класс Point3D, который 
наследует от класса Point2D и он пока будет пустым:
Тогда, для экземпляров этого класса будет разрешено создание локальных свойств, несмотря на то, что в 
базовом классе присутствует коллекция __slots__:
То есть, по умолчанию эта коллекция не наследуется дочерними классами и они ведут себя как обычные, без 
каких-либо ограничений, сохраняя все локальные свойства, используя коллекцию: 
"""
print(pt3.__dict__)
