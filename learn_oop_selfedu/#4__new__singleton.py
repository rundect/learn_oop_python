"""
Магический метод __new__. Пример паттерна Singleton
https://proproprogs.ru/python_oop/magicheskiy-metod-new-primer-patterna-singleton
"""


class Point:
    def __new__(cls, *args, **kwargs):
        print("вызов __new__ для " + str(cls))
        return super().__new__(cls)

    """
    Здесь функция super() возвращает ссылку на базовый класс и через нее мы вызываем метод __new__ с одним первым 
    аргументом. Начиная с версии Python 3, все классы автоматически и неявно наследуются от базового класса object.
    И уже из этого базового класса мы вызываем метод __new__. Кстати, если метод __new__ не прописывать в классе 
    Point, то будет автоматически запускаться версия базового класса. То есть, этот метод всегда вызывается при 
    создании нового объекта. При необходимости, мы можем его переопределять, добавляя новую логику его работы. И 
    то же самое относится ко всем магическим методам. Они всегда существуют у всех классов. Но переопределяем мы 
    лишь те, что необходимо, а остальные работают по умолчанию
    """

    def __init__(self, x=0, y=0):
        print("вызов __init__ для " + str(self))
        self.x = x
        self.y = y


pt = Point(1, 2)
print(pt)

"""
Мы в консоли увидим только одно сообщение от метода __new__. То есть, второй метод __init__ не был вызван и, кроме 
того, если мы распечатаем переменную pt, то увидим значение None, то есть, объект не был создан.
В Python магический метод __new__ должен возвращать адрес нового созданного объекта. А в нашей программе он ничего 
не возвращает, то есть, значение None, что эквивалентно отказу в создании нового объекта. Именно поэтому переменная 
pt принимает значение None
"""

# ------------ Пример паттерна Singleton
"""Мы разрабатываем класс для работы с БД. В частности, через него можно будет подключаться к СУБД, читать и записывать
информацию, закрывать соединение и полагаем, что в программе должен существовать только один экземпляр этого класса в 
каждый момент ее работы. То есть, одновременно два объекта класса DataBase быть не должно. Чтобы это обеспечить и 
гарантировать, как раз и используется паттерн Singleton"""


class DataBase:
    __instance = None

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)

        return cls.__instance

    def __init__(self, user, psw, port):
        self.user = user
        self.psw = psw
        self.port = port

    def connect(self):
        print(f"соединение с БД: {self.user}, {self.psw}, {self.port}")

    def close(self):
        print("закрытие соединения с БД")

    def read(self):
        return "данные из БД"

    def write(self, data):
        print(f"запись в БД {data}")

    def __del__(self):
        print("Удаление экземпляра: " + str(self))


"""Мы проверяем атрибут класса __instance. Причем, для обращения к нему 
используем параметр cls – ссылку на текущий класс. Далее, проверяем, если 
значение равно None, то вызываем метод __new__ базового класса и тем самым разрешаем создание объекта. Иначе, просто 
возвращаем ссылку на ранее созданный экземпляр."""


db = DataBase('root', '1234', 80)
db2 = DataBase('root2', '5678', 40)
print(id(db), id(db2))

db.connect()
db2.connect()

"""
Если попробовать создать два экземпляра, то их id ожидаемо будут равны. То есть, ссылки db и db2 действительно 
ведут на один объект. Но, если выполнить метод, то увидим значения: 'root2', '5678', 40 – аргументы при повторном 
создании класса. По идее, если объект не создается, то и локальные свойства его также не должны меняться. Почему так 
произошло? Все просто. Мы здесь действительно видим первый объект. Но при повторном вызове DataBase() также был 
вызван магический метод __init__ с новым набором аргументов и локальные свойства изменили свое значение
"""