
"""
https://proproprogs.ru/python_oop/svoystva-property-dekorator-property
Свойства property. Декоратор @property
"""


class Person:
    def __init__(self, name, old):
        self.__name = name
        self.__old = old

    """
    Так вот, мы можем использовать эти декораторы, чтобы сразу нужный нам метод класса превратить в объект-свойство 
    property. Делается это очень просто. Перед геттером (обратите внимание, именно перед геттером, а не сеттером или 
    делитером) прописывается декоратор
    """
    @property
    def old(self):
        return self.__old

    @old.setter
    def old(self, old):
        self.__old = old

    @old.deleter
    def old(self):
        del self.__old

    """
    Нам нужно прописывать разные сеттеры и геттеры для разных приватных атрибутов экземпляров класса. Например, 
    добавить еще два для __name. В результате, пользователю этого класса (программисту) придется запоминать и 
    держать в голове названия имен всех этих сеттеров и геттеров. Как можно было бы упростить работу с таким классом? 
    Один из способов – воспользоваться объектом property. Давайте посмотрим на конкретном нашем примере, как это 
    можно сделать.
    В самом классе Person мы пропишем атрибут и придумаем ему имя, допустим, old. Этот атрибут класса будет ссылаться 
    на объект property, которому мы передадим ссылку на геттер и сеттер.
    """
    # old = property(get_old, set_old)
    """
    Из каждого экземпляра класса мы совершенно спокойно можем обращаться к атрибуту класса old. Этот атрибут 
    является объектом property. Данный объект так устроен, что при считывании данных он вызывает первый метод 
    get_old, этот метод возвращает значение приватного локального свойства __old экземпляра класса p и именно 
    это значение дальше возвращается атрибутом old. Поэтому переменная a будет ссылаться на значение текущего 
    возраста сотрудника.
    Если же мы обращаемся к атрибуту класса old и присваиваем ему какое-то значение, то автоматически вызывается второй 
    метод set_old и в локальное свойство __old заносится значение, указанное после оператора присваивания. В итоге, в 
    текущем объекте p меняется локальное свойство __old на новое
    """

    """
    Декоратор – это функция, которая расширяет функционал другой функции. То есть, вот эту строчку:
    old = property(get_old, set_old)
    можно переписать и так:
    """
    # old = property()
    # old = old.setter(set_old)
    # old = old.getter(get_old)
    """
    Это будет одно и то же. При вызове метода setter осуществляется встраиванием метода set_old в алгоритм работы 
    объекта property. И то же самое делает метод getter только для геттера. В обоих случаях они возвращают ссылку на 
    объект property, который мы должны сохранять
    """


p = Person('Сергей', 20)

# p.set_old(35)
# print(p.get_old())

# print(p.old)
p.old = 35
print(p.old)
"""
почему строчка:
p.old = 35
не создает новое локальное свойство внутри объекта p, как это у нас было ранее в программах, а обращается именно 
к атрибуту класса Person? Все дело в приоритете. Если в классе задан атрибут как объект-свойство, то в первую 
очередь выбирается оно, даже если в экземпляре класса есть локальное свойство с таким же именем. В этом легко 
убедиться. Давайте создадим свойство с именем old прямо в объекте p через словарь __dict__
"""
p.__dict__['old'] = 'old in object p'
print(f'p.old = {p.old}')
print(p.__dict__)
"""
Отображается значение 35, а не строка, то есть, было обращение именно к объекту-свойству old класса Person. А если 
свойству old в классе присвоить, какое-либо числовое значение, например, то будет отображена строка из объекта p. 
Здесь уже срабатывают знакомые нам приоритеты: сначала локальная область видимости объекта, затем, класса. Вот 
этот момент нужно хорошо знать, при работе с объектами-свойствами.
Итак, теперь у нас есть класс и мы можем менять приватное свойство __old экземпляров этого класса через единый 
атрибут old (считывать информацию и записывать). Это гораздо удобнее использования сеттеров и геттеров. Здесь 
всего один атрибут и через него естественным образом происходит взаимодействие с закрытым свойством __old
"""


# --------------Декоратор @property

"""
В нашей реализации есть некое функциональное дублирование: мы можем работать с приватным свойством __old и через 
сеттер/геттер и через свойство класса old. Конечно, это не критичный момент и на него можно не обращать внимания. 
Но, на мой взгляд было бы лучше, если бы у нас был один интерфейс взаимодействия со свойством __old.
Класс property позволяет нам на уровне его объектов, использовать функции-декораторы. Если в консоли прописать:
"""
a = property()
"""
то через ссылку a нам будут доступны эти самые функции:
"""
# a.getter()  # декоратор для сеттера;
# a.setter()  # декоратор для геттера;
# a.deleter()  # декоратор для делитера

# print(p.get_old)

del p.old
print(p.__dict__)

