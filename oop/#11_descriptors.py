
"""
Дескрипторы (data descriptor и non-data descriptor)
https://proproprogs.ru/python_oop/deskriptory-data-descriptor-i-non-data-descriptor

Что вообще такое дескрипторы? Это класс, который содержит или один магический метод __get__ (называется non-data
descriptor (дескриптор не данных)), или класс, в котором дополнительно прописаны методы __set__ и/или __del__ (data
descriptor (дескриптор данных)).
Дескрипторы не данных не могут менять значения какого-либо свойства, так как не имеют сеттера и делитера. Они
служат только для считывания информации.
"""


class ReadIntX:
    def __set_name__(self, owner, name):
        self.name = "_x"

    def __get__(self, instance, owner):
        return getattr(instance, self.name)


class Integer:
    @classmethod
    def verify_coord(cls, coord):
        if type(coord) != int:
            raise TypeError("Координата должна быть целым числом")

    def __set_name__(self, owner, name):
        self.name = "_" + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        self.verify_coord(value)
        setattr(instance, self.name, value)


class Point3D:
    xr = ReadIntX()

    x = Integer()
    y = Integer()
    z = Integer()
    """
    Эти атрибуты и есть дескрипторы данных, через которые будет проходить взаимодействие. Итак, когда мы создавали 
    экземпляры классов Integer, то автоматически вызывался магический метод __set_name__, в котором параметр self 
    являлся ссылкой на создаваемый экземпляр класса; owner – ссылка на класс Point3D; name – имя атрибута (для 
    первого объекта x, затем, y и z). В этом методе мы формируем локальное свойство с именем атрибута, добавляя 
    перед ним одно нижнее подчеркивание (так принято делать при определении дескрипторов). В итоге, в экземплярах 
    классов будут храниться имена _x, _y, _z. 
    """

    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    # @classmethod
    # def verify_coord(cls, coord):
    #     if type(coord) != int:
    #         raise TypeError("Координата должна быть целым числом")
    #
    # @property
    # def x(self):
    #     return self._x
    #
    # @x.setter
    # def x(self, coord):
    #     self.verify_coord(coord)
    #     self._x = coord
    #
    # @property
    # def y(self):
    #     return self._y
    #
    # @y.setter
    # def y(self, coord):
    #     self.verify_coord(coord)
    #     self._y = coord
    #
    # @property
    # def z(self):
    #     return self._z
    #
    # @z.setter
    # def z(self, coord):
    #     self.verify_coord(coord)
    #     self._z = coord


pt = Point3D(1, 2, 3)
"""
Сработает инициализатор, а в нем идет обращение к дескрипторам x, y, z. В частности, мы им присваиваем переданные 
значения. В этом случае, в классе Integer срабатывает сеттер (магический метод __set__), параметр self – это 
ссылка на объект дескриптора; instance – ссылка на объект pt, из которого произошло обращение к дескриптору; 
value – присваиваемое значение. В этом сеттере мы выводим в консоль сообщение, что был вызван данный метод и 
отображаем сохраненное имя и присваиваемое значение. Следующей строчкой через ссылку instance, то есть, на 
экземпляр класса pt, формируем в нем локальное свойство с именем self.name и присваиваем значение value. В 
результате, в объекте pt появляются локальные свойства _x, _y, _z с соответствующими значениями.

Если затем, выполнить считывание данных через дескриптор, например, x, то автоматически сработает геттер 
(метод __get__), в котором self – это ссылка на объект Integer; instance – ссылка на экземпляр класса pt; 
owner – ссылка на класс Point3D. Мы здесь через ссылку instance обращаемся к словарю __dict__ и считываем 
значение нужного локального свойства, которое, затем, возвращается геттером. Это же значение автоматически 
возвращается и самим дескриптором.

Вот общая схема работы дескрипторов применительно к нашему классу Point3D. Теперь, сколько бы интерфейсов 
взаимодействия нам не понадобилось, мы легко их можем добавить в наш класс и все будет выглядеть понятно и 
компактно. На первый взгляд все это может показаться каким-то сложным и запутанным. Но, если внимательно во 
всем разобраться, то все предельно просто, только несколько громоздко. Именно громоздко, а не сложно. Поэтому, 
при необходимости, просто посмотрите несколько раз объяснение схемы и я уверен, каждый из вас поймет принцип ее 
работы. Ну а мы реализуем ее в нашей программе. 
"""


print(pt.__dict__)

print(pt.xr)
pt.xr = 5
print(pt.xr, pt.__dict__)
