
"""
https://proproprogs.ru/python_oop/python-nasledovanie-atributy-private-i-protected
Наследование. Атрибуты private и protected

_attribute (с одним подчеркиванием) – режим доступа protected (служит для обращения внутри класса и во всех его
дочерних классах)
__attribute (с двумя подчеркиваниями) – режим доступа private (служит для обращения только внутри класса)
"""


class Geom:
    name = 'Geom'

    def __init__(self, x1, y1, x2, y2):
        print(f"инициализатор Geom для {self.__class__}")
        self.__x1 = x1
        self.__y1 = y1
        self.__x2 = x2
        self.__y2 = y2

    """
    Для чего вообще нужны и когда используются приватные атрибуты. Мы говорили, что это закрытые от внешнего 
    вмешательства свойства или методы текущего класса, доступные только внутри этого класса и недоступные из других, 
    в том числе и из дочерних классов. Именно поэтому приватные атрибуты жестко привязываются к текущему классу, 
    в котором они создаются, так как по логике предполагается их использовать только внутри этого класса и больше нигде
    """
    def get_coords(self):
        return self.__x1, self.__y1, self.__x2, self.__y2


class Rect(Geom):
    def __init__(self, x1, y1, x2, y2, fill='red'):
        super().__init__(x1, y1, x2, y2)
        self.__fill = fill


r = Rect(0, 0, 10, 20)
print(r.__dict__)
"""Локальные свойства с координатами имеют префикс _Geom, то есть, префикс того класса, в котором они непосредственно 
были прописаны. Несмотря на то, что параметр self является ссылкой на объект класса Rect. Это особенность поведения (
формирования) приватных атрибутов в базовых классах. У них всегда добавляется префикс именно базового класса, 
а не класса объекта self. А вот последнее свойство __fill имеет ожидаемый префикс _Rect, так как оно было создано в 
классе Rect """

r.get_coords()

# ---------------- Атрибуты protected
"""
Если же нам нужно определить закрытые атрибуты, доступные в текущем классе и во всех его дочерних классах, 
то для этого следует использовать метод определения protected – одно нижнее подчеркивание. Поэтому правильнее было бы 
создавать свойства-координаты в базовом инициализаторе в режиме protected
"""


class Geom1:
    _name = 'Geom1'

    def __init__(self, x1, y1, x2, y2):
        print(f"инициализатор {self._name}")
        self._x1 = x1
        self._y1 = y1
        self._x2 = x2
        self._y2 = y2

    def __verify_coord(self, coord):
        return 0 <= coord <= 100


class Rect1(Geom1):
    def __init__(self, x1, y1, x2, y2, fill='red'):
        super().__init__(x1, y1, x2, y2)
        self._fill = fill

    def get_coords(self):
        return self._x1, self._y1, self._x2, self._y2


r1 = Rect1(0, 0, 10, 20)
print(r1.__dict__)
r1.get_coords()
print(r1._x1)

"""
Нижнее подчеркивание лишь предупреждает (сигнализирует) программиста о защищенном атрибуте, к которому напрямую 
лучше не обращаться. Этот атрибут был создан для внутренней логики работы алгоритма в классе и не предназначен для 
обращения извне. В дальнейшем это может привести к проблемам, например, при изменении версии класса, в котором такого 
атрибута уже не будет, или он будет играть другую роль и т.п.
"""

# -------------- Атрибуты private и protected на уровне класса
"""
Все также работает и с атрибутами уровня класса. Например, сейчас мы совершенно спокойно можем обратиться к свойству
name класса Geom через объект класса Rect
Добавив одно нижнее подчеркивание, функционал останется прежним, мы лишь отметим, что к этой переменной извне лучше 
не обращаться
Но, если прописать два подчеркивания, то доступ будет закрыт всюду, кроме самого класса Geom
"""
# print(r1.name)
print(r1._name)
# print(r1.__name)

"""
Приватность запрещает переопределение методов в дочерних классах. Если же у метода прописать только одно 
подчеркивание, то его можно будет вызывать во всех дочерних классах
"""
